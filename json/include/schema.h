#ifndef SCHEMA_H
#define SCHEMA_H

// Generated by the kbuf.  DO NOT EDIT!
// source: schema.json

#include "schema.pb.h"
#include <sstream>
#include "google/protobuf/util/json_util.h"
#include "viidbasedata.h"
#include "viidjsonreadhandler.h"


static Document *g_test1Doc = nullptr;
static SchemaDocument *g_test1SmDoc = nullptr;

class CTest1 : public CViidBaseData
{
public:
	typedef shared_ptr<CTest1> sharedPtr;

	CTest1()
	{
		Init();
	}
	CTest1(test1 *data)
	{
		m_data = data;
		m_bOutData = false;
		InitSchema();
	}

	static sharedPtr CreateTest1()
	{
		sharedPtr sp(new CTest1);
		sp->m_data = new test1;
		sp->m_bOutData = false;
		sp->InitSchema();
		return sp
		;
	}

	static sharedPtr CreateTest1WithData(test1 *data)
	{
		sharedPtr sp(new CTest1);
		sp->m_data = data;
		sp->m_bOutData = true;
		sp->InitSchema();
		return sp;
	}

	void Init()
	{
		m_data = new test1;
		m_bOutData = false;
		InitSchema();
	}

	~CTest1()
	{
		Release();
	}

	void Release()
	{
		if(m_data && !m_bOutData)
		{
			delete m_data;
			m_data = nullptr;
		}
	}

	string &ToString(string &str, bool read = false)
	{
		rapidjson::StringBuffer buffer;
		rapidjson::Writer<StringBuffer> writer(buffer);
		ToStringWriter(writer, read);
		str = buffer.GetString();
		return str;
	}

	void ToStringWriter(rapidjson::Writer<StringBuffer> &writer, bool read = false)
	{
		writer.StartObject();

		writer.String("age");
		writer.Double(m_data->age());

		writer.String("name");
		writer.String(m_data->name().c_str());

		if(!read)
		{
			writer.String("EntryTime");
			writer.String(getEntryTime().c_str());
			writer.String("KDExpiredDate");
			writer.String(getExpiredTime().c_str());
		}

		writer.EndObject();
	}

	string& ToStringByProto(string &str) const
	{
		google::protobuf::util::JsonPrintOptions op;
		op.add_whitespace = false;
		
		google::protobuf::util::Status st = MessageToJsonString(*m_data, &str, op);
		if(!st.ok())
		{
			str.clear();
		}
		
		return str;
	}

	string &ToStringWithSpecifiedField(string &str, const set<string> fields)
	{
		rapidjson::StringBuffer buffer;
		rapidjson::Writer<StringBuffer> writer(buffer);

		writer.StartObject();

		__attribute__((unused)) auto end = fields.end();
		if(fields.find("age") != end)
		{
			writer.String("age");
			writer.Double(m_data->age());
		}

		if(fields.find("name") != end)
		{
			writer.String("name");
			writer.String(m_data->name().c_str());
		}

		writer.EndObject();
		str = buffer.GetString();
		return str;
	}

	bool FromString(const string &str)
	{
		auto sp = Ctest1::Createtest1WithData(this->m_data);
		viidJsonReadHandler handler(sp);

		Reader rd;
		StringStream ss(str.c_str());
		GenericSchemaValidator<SchemaDocument, viidJsonReadHandler> validator(*(g_test1SmDoc), handler);
		ParseResult ok = rd.Parse<kParseValidateEncodingFlag>(ss, validator);
		if(!ok)
		{
			string err(GetParseError_En(ok.Code()));
			SetErrStr(err);
			if(!validator.IsValid())
			{
				StringBuffer sb;
				Writer<StringBuffer> w(sb);
				validator.GetError().Accept(w);
				SetErrStr(sb.GetString());
			}
			return false;
		}
		return true;
	}

	bool FromStringNoCheck(const string &str)
	{
		auto sp = Ctest1::Createtest1WithData(this->m_data);
		viidJsonReadHandler handler(sp);
		Reader rd;
		StringStream ss(str.c_str());
		if(!rd.Parse<kParseValidateEncodingFlag>(ss, handler))
		{
			return  false;
		}
		return true;
	}

	bool FromStringProto(const string &str)
	{
		google::protobuf::util::JsonParseOptions op;
		op.ignore_unknown_fields = true;
		JsonStringToMessage(str, this->m_data, op);
		return true;
	}

	bool Serialize(CSerialBuf &buf) const
	{
		buf.SetLen(m_data->ByteSize());
		return m_data->SerializeToArray(buf.GetBuf(), buf.GetLen());
	}

	bool DeSerialize(const void * data, int size)
	{
		return m_data->ParseFromArray(data, size);
	}

	bool ObjectBegin(hash_t hKey, SP_Data &newPtr)
	{
		// should not be here
		return false;
	}

	bool SetString(hash_t hKey, const char* value, size_t length)
	{
		switch (hKey) 
		{
		case "name"_hash: // 14176396743819860870
			{
				m_data->set_name(value);
				break;
			}
		default:
			{
				// should not be here
				// TODO log err
			}
		}
		return true;
	}

	bool SetNull(hash_t hKey)
	{
		return true;
	}

	bool SetBool(hash_t hKey, bool value)
	{
		return true;
	}

	bool SetInt(hash_t hKey, int64_t value)
	{
		return true;
	}

	bool SetDouble(hash_t hKey, double value)
	{
		switch (hKey) 
		{
		case "age"_hash: // 16651413216827089244
			{
				m_data->set_age(value);
				break;
			}
		default:
			{
				// should not be here
				// TODO log err
			}
		}
		return true;
	}

	test1 *GetData()
	{
		return  m_data;
	}


private:
	void InitSchema()
	{
		return;
	}
private:
	test1 *m_data;
	string m_strSchema;
	bool m_bOutData;
};
#endif